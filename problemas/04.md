# C# avançado e _design patterns_

1 - Considera a classe
[`ZipFile`](https://docs.microsoft.com/dotnet/api/system.io.compression.zipfile).
Que _design pattern_ pattern está a ser implementado por esta classe. Justifica
a tua resposta.

> [Soluções](../solucoes/04/001.md)

---

2 - Usando as interfaces nativas do C# para implementação do _Decorator
pattern_, nomeadamente
[`IObserver<T>`](https://docs.microsoft.com/dotnet/api/system.iobserver-1) e
[`IObservable<T>`](https://docs.microsoft.com/dotnet/api/system.iobservable-1),
implementa:

1.  Um sujeito/observável que leia teclas do teclado (suprimindo a tecla lida
    de modo a que não apareça no ecrã) e notifique os observadores cada vez que
    uma tecla é premida.
2.  Um observador que indique no ecrã a tecla lida (e.g. `Detetada tecla
    'R'`).
3.  Um observador que guarde o carácter associado à tecla num ficheiro (em modo
    _append_).

> [Soluções](../solucoes/04/002.md)

---

3 - Resolve o exercício anterior com recurso a eventos.

> [Soluções](../solucoes/04/003.md)

---

4 - Cria os seguintes métodos de extensão para a classe
[`string`](https://docs.microsoft.com/dotnet/api/system.string):

1.  Método que conta o número de palavras numa _string_. Podes usar o método
[`Split()`](https://docs.microsoft.com/dotnet/api/system.string.split) para
dividir a _string_ em várias palavras, mas certifica-te que todos os caracteres
de _whitespace_ (i.e. espaços, tabs, _new lines_, etc) são usados como
separadores de palavras (estuda a documentação do método de modo para
perceberes como). Deves ainda ignorar palavras com comprimento zero.
2.  Método que conte o número de frases numa _string_. Podes assumir que uma
frase termina com um ponto final. Frases de comprimento zero ou só com
_whitespace_ não devem ser contadas.
3.  Método que conte o número de parágrafos numa _string_. Podes assumir que um
parágrafo termina com uma nova linha (carácter `\n`). Parágrafos com
comprimento zero ou só com _whitespace_ não devem ser contados.

Para testares os métodos, cria um programa que conte as palavras, frases e
parágrafos num ficheiro de texto, cujo nome deve ser passado como argumento na
linha de comandos. Neste programa deves apanhar e tratar todas as excepções que
possam ser lançadas pelo código de leitura do ficheiro.

> [Soluções](../solucoes/04/004.md)

---

5 - Cria um programa que apresente as seguintes estatísticas sobre um projeto
em C#:

1.  Número de linhas de código
2.  Número de linhas em branco (apenas _whitespace_)
3.  Número de linhas que são comentários (i.e. linhas que começam com `//`,
    ignorando comentários do estilo `/* ... */`)

Para o efeito deves criar três métodos de extensão apropriados com os nomes
`IsLineOfCode()`, `IsBlank()` e `IsComment()`, que devolvem um booleano
indicando se a linha (_string_) é do tipo em questão.

O programa deve receber como argumento da linha de comando uma pasta ou um
nome de ficheiro. Se for indicada uma pasta, o programa deve indicar a
estatística global para todos os ficheiros `.cs` na pasta e respetivas
sub-pastas. Caso seja indicado um ficheiro, o programa deve certificar-se que o
mesmo tem extensão `.cs` e mostrar as estatísticas apenas para esse ficheiro.

Este programa deve ser estruturado de acordo com as melhores práticas de
tratamento de exceções, design de classes e _design patterns_.

> [Soluções](../solucoes/04/005.md)

---

6 - Considera o
[exercício 7](https://github.com/VideojogosLusofona/lp2_2018_aulas/tree/master/Aula07/Exercicio7)
da
[aula 7](https://secure.grupolusofona.pt/ulht/moodle/mod/resource/view.php?id=158347).
Implementa um sistema de _achievements_ para o jogo. O sistema de _achivements_
deve ter as seguintes responsabilidades:

*   Conter uma referência para cada _achievement_ possível no jogo.
*   Cada uma dessas referências deve indicar se o respetivo _achievement_ já
    foi alcançado ou não, ou que percentagem ou partes do _achievement_ já
    foram completadas.
*   Registar um ou mais métodos em eventos pré-existentes que possam significar
    um _achievement_. No caso de eventos do tipo
    [`UnityEvent`](https://docs.unity3d.com/Manual/UnityEvents.html), o método
    ou métodos deve/devem ser registados de forma programática (no código) e
    não no editor. O método ou métodos em questão deve/devem verificar se o
    evento corresponde à completação parcial ou total de um _achievement_, e em
    caso afirmativo atualizar a respetiva referência ao mesmo.
*   Cada vez que um _achievement_ for alcançado, deve ser mostrada uma frase a
    verde na parte inferior da área de jogo, indicando o título do
    _achievement_ em questão e a percentagem de _achievements_ completados.

Inicialmente devem ser contemplados os seguintes  _achievements_:

*   **Gotcha** - Apanhar um alvo.
*   **Outlaw** - Ultrapassar o limite de velocidade.
*   **Persistent** - Apanhar 10 alvos.
*   **Bouncer** - Bater nas 4 paredes.

O sistema de _achievements_ deve ser implementado de acordo com as as melhores
práticas de design de classes e _design patterns_, tal que seja simples
adicionar mais _achievements_ posteriormente.

> [Soluções](../solucoes/04/006.md)
