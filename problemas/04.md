# C# avançado e _design patterns_

1 - Considera a classe
[`ZipFile`](https://docs.microsoft.com/dotnet/api/system.io.compression.zipfile).
Que _design pattern_ pattern está a ser implementado por esta classe. Justifica
a tua resposta.

> [Soluções](../solucoes/04/001.md)

---

2 - Usando as interfaces nativas do C# para implementação do _Decorator
pattern_, nomeadamente
[`IObserver<T>`](https://docs.microsoft.com/dotnet/api/system.iobserver-1) e
[`IObservable<T>`](https://docs.microsoft.com/dotnet/api/system.iobservable-1),
implementa:

1.  Um sujeito/observável que leia teclas do teclado (suprimindo a tecla lida
    de modo a que não apareça no ecrã) e notifique os observadores cada vez que
    uma tecla é premida.
2.  Um observador que indique no ecrã a tecla lida (e.g. `Detetada tecla
    'R'`).
3.  Um observador que guarde o carácter associado à tecla num ficheiro (em modo
    _append_).

> [Soluções](../solucoes/04/002.md)

---

3 - Resolve o exercício anterior com recurso a eventos.

> [Soluções](../solucoes/04/003.md)

---

4 - Cria os seguintes métodos de extensão para a classe
[`string`](https://docs.microsoft.com/dotnet/api/system.string):

1.  Método que conta o número de palavras numa _string_. Podes usar o método
[`Split()`](https://docs.microsoft.com/dotnet/api/system.string.split) para
dividir a _string_ em várias palavras, mas certifica-te que todos os caracteres
de _whitespace_ (i.e. espaços, tabs, _new lines_, etc) são usados como
separadores de palavras (estuda a documentação do método de modo para
perceberes como). Deves ainda ignorar palavras com comprimento zero.
2.  Método que conte o número de frases numa _string_. Podes assumir que uma
frase termina com um ponto final. Frases de comprimento zero ou só com
_whitespace_ não devem ser contadas.
3.  Método que conte o número de parágrafos numa _string_. Podes assumir que um
parágrafo termina com uma nova linha (carácter `\n`). Parágrafos com
comprimento zero ou só com _whitespace_ não devem ser contados.

Para testares os métodos, cria um programa que conte as palavras, frases e
parágrafos num ficheiro de texto, cujo nome deve ser passado como argumento na
linha de comandos. Neste programa deves apanhar e tratar todas as excepções que
possam ser lançadas pelo código de leitura do ficheiro.

> [Soluções](../solucoes/04/004.md)

---

5 - Cria um programa que apresente as seguintes estatísticas sobre um projeto
em C#:

1.  Número de linhas de código
2.  Número de linhas em branco (apenas _whitespace_)
3.  Número de linhas que são comentários (i.e. linhas que começam com `//`,
    ignorando comentários do estilo `/* ... */`)

Para o efeito deves criar três métodos de extensão apropriados com os nomes
`IsLineOfCode()`, `IsBlank()` e `IsComment()`, que devolvem um booleano
indicando se a linha (_string_) é do tipo em questão.

O programa deve receber como argumento da linha de comando uma pasta ou um
nome de ficheiro. Se for indicada uma pasta, o programa deve indicar a
estatística global para todos os ficheiros `.cs` na pasta e respetivas
sub-pastas. Caso seja indicado um ficheiro, o programa deve certificar-se que o
mesmo tem extensão `.cs` e mostrar as estatísticas apenas para esse ficheiro.

Este programa deve ser estruturado de acordo com as melhores práticas de
tratamento de exceções, design de classes e _design patterns_.

Apresenta também o diagrama UML simples (sem campos e métodos) da solução.

> [Soluções](../solucoes/04/005.md)

---

6 - Considera o
[exercício 7](https://github.com/VideojogosLusofona/lp2_2018_aulas/tree/master/Aula07/Exercicio7)
da
[aula 7](https://secure.grupolusofona.pt/ulht/moodle/mod/resource/view.php?id=158347).
Implementa um sistema de _achievements_ para o jogo. O sistema de _achivements_
deve ter as seguintes responsabilidades:

*   Conter uma referência para cada _achievement_ possível no jogo.
*   Cada uma dessas referências deve indicar se o respetivo _achievement_ já
    foi alcançado ou não, ou que percentagem ou partes do _achievement_ já
    foram completadas.
*   Registar um ou mais métodos em eventos pré-existentes que possam significar
    um _achievement_. No caso de eventos do tipo
    [`UnityEvent`](https://docs.unity3d.com/Manual/UnityEvents.html), o método
    ou métodos deve/devem ser registados de forma programática (no código) e
    não no editor. O método ou métodos em questão deve/devem verificar se o
    evento corresponde à completação parcial ou total de um _achievement_, e em
    caso afirmativo atualizar a respetiva referência ao mesmo.
*   Cada vez que um _achievement_ for alcançado, deve ser mostrada uma frase a
    verde na parte inferior da área de jogo, indicando o título do
    _achievement_ em questão e a percentagem de _achievements_ completados.

Inicialmente devem ser contemplados os seguintes  _achievements_:

*   **Gotcha** - Apanhar um alvo.
*   **Outlaw** - Ultrapassar o limite de velocidade.
*   **Persistent** - Apanhar 10 alvos.
*   **Bouncer** - Bater nas 4 paredes.

O sistema de _achievements_ deve ser implementado de acordo com as as melhores
práticas de design de classes e _design patterns_, tal que seja simples
adicionar mais _achievements_ posteriormente.

Apresenta também o diagrama UML simples (sem campos e métodos) da solução.

> [Soluções](../solucoes/04/006.md)

---

7 - Simplifica ao máximo a seguinte _struct_ usando lambdas e eventualmente
operadores ternários:

```cs
public struct GameMap
{
    private float topScore;
    private int gamesPlayed;
    private int gamesWon;

    public string Name { get; }
    public string Filename { get; }
    public float SuccessRate
    {
        get {
            if (gamesPlayed == 0)
                return 0f;
            else
                return gamesWon / (float) gamesPlayed;
        }
    }
    public float TopScore {
        get
        {
            return topScore;
        }
        set
        {
            if (value > topScore)
            {
                topScore = value;
            }
        }
    }

    public GameMap(string name, string filename)
    {
        Name = name;
        Filename = filename;
        gamesPlayed = 0;
        gamesWon = 0;
        topScore = 0;
    }

    public void GamePlayed(bool won)
    {
        gamesPlayed++;
        if (won)
        {
            gamesWon++;
        }
    }
}
```

> [Soluções](../solucoes/04/007.md)

---

8 - Simplifica ao máximo o seguinte código usando lambdas e eventualmente
operadores ternários:

```cs
public struct Bullet
{
    private float calibre;
    public float Calibre
    {
        get { return calibre; }
        set { if (value < 0.1f) calibre = 0.1f; else calibre = value; }
    }
}
```

```cs
public class Weapon
{
    public float Value { get; }
    public Weapon(float value) { Value = value; }
}
```

```cs
public class Gun : Weapon
{
    private Bullet[] bullets;
    public Gun(float value, int numBullets, float calibre) : base(value)
    {
        bullets = new Bullet[numBullets];
        for (int i = 0; i < numBullets; i++)
        {
            bullets[i] = new Bullet() { Calibre = calibre };
        }
    }
}
```

> [Soluções](../solucoes/04/008.md)

---

9 - Simplifica ao máximo o seguinte código usando lambdas e eventualmente
operadores ternários:

```cs
public struct Passenger
{
    private double weight;
    public double Weight
    {
        get { return weight; }
        set { if (value < 5) weight = 5; else weight = value; }
    }
}
```

```cs
public class Vehicle
{
    public double Value { get; }
    public Vehicle(double value) { Value = value; }
}
```

```cs
public class Car : Vehicle
{
    private Passenger[] passengers;
    public Car(double value, int numPassengers, float avgWeight) : base(value)
    {
        Random r = new Random();
        passengers = new Passenger[numPassengers];
        for (int i = 0; i < numPassengers; i++)
        {
            passengers[i] = new Passenger()
            {
                Weight = avgWeight + r.Next(-10, 10)
            };
        }
    }
}
```

> [Soluções](../solucoes/04/009.md)

---

10 - Considera a seguinte classe:

```cs
public static class VectorOperations
{
    // Normalized direction between two game objects
    public static Vector2 Direction(Vector2 from, Vector2 to)
    {
        return (to - from) / (to - from).magnitude;
    }

    // Distance between two game objects
    public static float Distance(Vector2 obj1, Vector2 obj2)
    {
        return (obj1 - obj2).magnitude;
    }

    // Convert angle in degrees into normalized vector
    public static Vector2 Deg2Vec(float angle)
    {
        float angleRad = angle * Mathf.Deg2Rad;
        return new Vector2(Mathf.Cos(angleRad), Mathf.Sin(angleRad));
    }

    // Determine angle of vector in degrees
    public static float Vec2Deg(Vector2 vector)
    {
        return Mathf.Atan2(vector.y, vector.x) * Mathf.Rad2Deg;
    }
}
```

Responde às seguintes questões:

1.  Simplifica os métodos usando lambas.
2.  Declara, para cada método, um _delegate_ personalizado compatível.
3.  Indica, para cada método, um _delegate_ pré-definido do C# que seja
    compatível.
4.  Assumindo que estás num método noutra classe, escreve quatro linhas de
    código nas quais declaras quatro variáveis do tipo _delegate_ pré-definido
    que indicaste na alínea anterior, atribuindo-lhes o respetivo método
    compatível.
5.  Repete a alínea anterior mas considerando os _delegates_ personalizados que
    declaraste na alínea 2 (e não os _delegates_ pré-definidos do C#).

> [Soluções](../solucoes/04/010.md)

---

11 - Considera o seguinte código:

```cs
public class EventProducer
{
    public string Str { get; private set; }
    public int N { get; private set; }

    protected virtual void OnProducedEvent()
    {
        ProducedEvent?.Invoke(Str, N);
    }
    public event Action<string, int> ProducedEvent;
}
```

O código anterior funciona perfeitamente, mas tens um patrão chato que exige
que uses _delegates_ propositadamente criados para uso em eventos. Assim sendo,
substitui o _delegate_ pré-definido
[`Action<T1,T2>`](https://docs.microsoft.com/dotnet/api/system.action-2)
pelo _delegate_ pré-definido
[`EventHandler<TEventArgs>`](https://docs.microsoft.com/dotnet/api/system.eventhandler-1),
alterando o código em conformidade. Poderá ser necessário criar uma classe
adicional.

> [Soluções](../solucoes/04/011.md)

---

12 - Compara a documentação dos _delegates_ pré-definidos
[`Action`](https://docs.microsoft.com/dotnet/api/system.action)
e
[`ThreadStart`](https://docs.microsoft.com/dotnet/api/system.threading.threadstart).
Porque razão não é possível utilizar o delegate `Action` em _threads_, tendo em
conta que ambos os _delegates_ devolvem `void` e não aceitam parâmetros.

> [Soluções](../solucoes/04/012.md)

---

13 - Qual é ou quais são as diferenças entre _delegates_ e eventos no C#?

> [Soluções](../solucoes/04/013.md)

---

14 - Que _design pattern_ é explicitamente implementado pelos eventos do C#?
Explica o teu raciocínio.

> [Soluções](../solucoes/04/014.md)

---

15 - _Brevemente_
<!-- get site and make stats queries using lambdas -->

> [Soluções](../solucoes/04/015.md)

---

16 - _Brevemente_

> [Soluções](../solucoes/04/016.md)

---

17 - _Brevemente_

> [Soluções](../solucoes/04/017.md)

---

18 - _Brevemente_

> [Soluções](../solucoes/04/018.md)

---

19 - _Brevemente_

> [Soluções](../solucoes/04/019.md)

---

20 - _Brevemente_

> [Soluções](../solucoes/04/020.md)

---

21 - _Brevemente_

> [Soluções](../solucoes/04/021.md)

---
