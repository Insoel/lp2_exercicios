## Problema

2 - Usando as interfaces nativas do C# para implementação do _Observer
pattern_, nomeadamente
[`IObserver<T>`](https://docs.microsoft.com/dotnet/api/system.iobserver-1) e
[`IObservable<T>`](https://docs.microsoft.com/dotnet/api/system.iobservable-1),
implementa:

1.  Um sujeito/observável que leia teclas do teclado (suprimindo a tecla lida
    de modo a que não apareça no ecrã) e notifique os observadores cada vez que
    uma tecla é premida.
2.  Um observador que indique no ecrã a tecla lida (e.g. `Detetada tecla
    'R'`).
3.  Um observador que guarde o carácter associado à tecla num ficheiro (em modo
    _append_).

O programa deve terminar quando for pressionada a tecla _Escape_.

## Soluçoes

### Solução 1

```cs
using System;

namespace PatternObserver
{
    class Program
    {
        static void Main(string[] args)
        {
            // Variaveis Idisposable
            IDisposable sub1, sub2;
            // Instancia da clase Subject
            Subject sub = new Subject();
            // Instancia da clase Observer1
            IObserver<ConsoleKeyInfo> obs = new Observer1();
            // Instancia da clase Observer2
            IObserver<ConsoleKeyInfo> obfile = new Observer2();

            // Resistase o primer observador
            sub1 = sub.Subscribe(obs);
            // Resistase o segundo observador
            sub2 = sub.Subscribe(obfile);
            // Utilizanse os metodos da clase Subject
            sub.ReadKeyboard();

            // apaga a subscripçao do ovservador1
            sub1.Dispose();
            // apaga a subscripçao do ovservador2
            sub2.Dispose();         
        }
    }
}

```

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace PatternObserver
{
    public class Unsubscriber : IDisposable
    {
        // Lista de subscritores
        private ICollection<IObserver<ConsoleKeyInfo>> _observers;
        // O que vai a levar o Unsubscribe
        private IObserver<ConsoleKeyInfo> _observer;

        // Constructor
        public Unsubscriber(ICollection<IObserver<ConsoleKeyInfo>> observers,
            IObserver<ConsoleKeyInfo> observer)
        {
            // Inicializaçao dos observadores
            this._observers = observers;
            // Inicializaçao do subscriber
            this._observer = observer;
        }

        public void Dispose()
        {
            // Apaga os subscribers.
            if (_observer != null && _observers.Contains(_observer))
                _observers.Remove(_observer);
        }
    }
}
```

```cs
using System;
using System.Collections.Generic;

namespace PatternObserver
{
    public class Subject : IObservable<ConsoleKeyInfo>
    {
        // Declarase um observador tipo Icollection<IObserver<ConsoleKeyInfo>>
        private readonly ICollection<IObserver<ConsoleKeyInfo>> observer;

        private ConsoleKeyInfo kp;
        public ConsoleKeyInfo KP
        {
            get
            {
                // Return the latest key read
                return kp;
            }
            private set
            {
                // Set the latest key read
                kp = value;
                // Notify observers that we have a new key read
                NotifyObservers();
            }
        }

        // Constructor que crea os novos observadores num HasSet.
        public Subject()
        {
            observer = new HashSet<IObserver<ConsoleKeyInfo>>();
        }

        // Subscrebe os novos observadores.
        public IDisposable Subscribe(IObserver<ConsoleKeyInfo> ob)
        {
            // Adicionase o observador ao HasSet<IObserver>
            observer.Add(ob);
            return new Unsubscriber(observer, ob);
        }

        public void NotifyObservers()
        {
            // Recorrese cada observador
            foreach (IObserver<ConsoleKeyInfo> ob in observer)
            {
                // Actualizase cada observador recebendo o novo input
                ob.OnNext(KP);
            }
        }

        public void ReadKeyboard()
        {
            // Recebe os input do teclado mentres nao presionas esc
            do
            {
                // Lee os input do teclado e true para nao mostrar no ecra
                KP = Console.ReadKey(true);

            } while (KP.Key != ConsoleKey.Escape);
        }
    }
}
```

```cs
using System;

namespace PatternObserver
{
    class Observer1 : IObserver<ConsoleKeyInfo>
    {
        public void OnCompleted()
        {
            throw new NotImplementedException();
        }

        public void OnError(Exception error)
        {
            throw new NotImplementedException();
        }

        public void OnNext(ConsoleKeyInfo value)
        {
            // Mostra por consola a mensagem
            Console.WriteLine("Detetada a tecla " + value.KeyChar);
        }
    }
}
```

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace PatternObserver
{
    class Observer2 : IObserver<ConsoleKeyInfo>
    {
        public void OnCompleted()
        {
            throw new NotImplementedException();
        }

        public void OnError(Exception error)
        {
            throw new NotImplementedException();
        }

        public void OnNext(ConsoleKeyInfo value)
        {
            // Cria o ficheiro de escritura com Append.
            using (StreamWriter wr = File.AppendText("input.txt"))
            {
                // Escreve as letras premidas no ecra.
                wr.Write(value.KeyChar);
            }
        }
    }
}

```
 *Por [Alejandro Urcera](https://github.com/aurceramartins)*
