## Problema

Usando as interfaces nativas do C# para implementação do Decorator pattern, nomeadamente IObserver<T> e IObservable<T>, implementa:

    1- Um sujeito/observável que leia teclas do teclado (suprimindo a tecla lida de modo a que não apareça no ecrã) e notifique os observadores cada vez que uma tecla é premida.
    2- Um observador que indique no ecrã a tecla lida (e.g. Detetada tecla 'R').
    3- Um observador que guarde o carácter associado à tecla num ficheiro (em modo append).

## Soluçoes

### Solução 1

```cs
using System;
namespace PatternObserver
{
    class Program
    {
        static void Main(string[] args)
        {
            // Instancia da clase Subject
            Subject sub = new Subject();
	     // Instancia da clase Observer1
            IOvserver obs = new Observer1();
            // Instancia da clase Observer2
            IOvserver obfile = new Observer2();            

            // Resistase o primer observador
            sub.RegisterObserver(obs);
            // Resistase o segundo observador
            sub.RegisterObserver(obfile);
            // Utilizanse os metodos da clase Subject
            sub.ReadKeyboard();
        }
    }
}


namespace PatternObserver
{
    public interface IObservable
    {
        // Metodo para resistrar observadores
        void RegisterObserver(IOvserver obs);
        // Metodo para leer os inputs do teclado
        void ReadKeyboard();
        // Metodo para notificar ao observadores.
        void NotifyObserver();
    }
}


namespace PatternObserver
{
    public interface IOvserver
    {
        //Metodo update no que se actualizaram os cambios.
        void Update(IObservable sub);
    }
}


using System;
using System.Collections.Generic;
namespace PatternObserver
{
    public class Subject : IObservable
    {
        // Declarase um observador tipo Icollection<IObserver>
        ICollection<IOvserver> observer;
        // Propiedade KP tipo devolve ConsoleKeyInfo, set privado.
        public ConsoleKeyInfo KP { get; private set; }
        // Constructor que crea os novos observadores num HasSet.
        public Subject()
        {
            observer = new HashSet<IOvserver>();
        }

        public void RegisterObserver(IOvserver obs)
        {
            // Adicionase o observador ao HasSet<IObserver>
            observer.Add(obs);
        }

        public void NotifyObserver()
        {
            // Recorrese cada observador
            foreach (IOvserver ob in observer)
            {
                // Actualizase cada observador coa informaçao
                // que tem a clase Subject
                ob.Update(this);
            }
        }

        public void ReadKeyboard()
        {
            // Recebe os input do teclado mentres nao presionas esc
            do
            {
                // Lee os input do teclado e true para nao mostrar
                // no ecra
                KP = Console.ReadKey(true);
	         // Notifica as mudanças aos Observadores
                NotifyObserver();

            } while (KP.Key != ConsoleKey.Escape);
        }
    }
}


using System;
namespace PatternObserver
{
    class Observer1 : IOvserver
    {
        // Implementaçao da interface IOvserver
        public void Update(IObservable sub)
        {
            // Guarda as teclas premidas no teclado
            ConsoleKeyInfo k = (sub as Subject).KP;
            // Mostra por consola a mensagem
            Console.WriteLine("Detetada a tecla " + k.KeyChar);
        }
    }
}


using System.IO;
namespace PatternObserver
{
    class Observer2 : IOvserver
    {
        // Implementaçao da interface IOvserver
        public void Update(IObservable sub)
        {
	     // Cria o ficheiro de escritura com Append.
            using (StreamWriter wr = File.AppendText("input.txt"))
            {
                // Escreve as letras premidas no ecra.
                wr.Write((sub as Subject).KP.KeyChar);
            }
        }
    }
}


```
 *Por [Alejandro Urcera](https://github.com/aurceramartins)*